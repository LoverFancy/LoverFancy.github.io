---
layout:     post
title:      数据结构与算法
subtitle:   数据结构与算法总结
date:       2018-05-26
author:     SkioFox
header-img: img/post-bg-debug.png
catalog: true
tags:
- 数据结构
- 算法
- 计算机基础
- javascript
---


## 数据结构类型

- 数据结构分类
    - 数据结构是指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成（说白了就是组织数据的方式）。 
    - 常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等，如图所示：
    - 每一种数据结构都有着独特的数据存储方式。

    ![avatar](/img/dataStructureAndAlgorithm/data-structure-map.png)

- 四大常用结构

    ![avatar](/img/dataStructureAndAlgorithm/data-structure-map-1.png)

- 数据结构和算法类别

    ![avatar](/img/dataStructureAndAlgorithm/DataStructureAndAlgorithm.jpg)

- Big O notation （时间和空间复杂度）

    ![avatar](/img/dataStructureAndAlgorithm/BigONotation.jpg)

    示例如下：

    ![avatar](/img/dataStructureAndAlgorithm/example.jpg)
    ![avatar](/img/dataStructureAndAlgorithm/example1.jpg)

    O^n 变化图

    ![avatar](/img/dataStructureAndAlgorithm/example2.jpg)

    - 递归（recursion）

        ```python

        # 斐波纳契数组 是O(2^n) 时间复杂度
        # Fibonacci array:1,1,2,3,5,8,13,21,34,...

        # F(n) = F(n-1) + F(n-2)

        def fib(n):
            if n==0 or n==1:
                return n
            return fib(n-1) + fib(n-2)

        ```
    
    - 常用几类递归算法的时间复杂度

        - 二分查找：O(log n)
        - 二叉树遍历：O(n)
        - 排序和二维矩阵的查找：O(n)
        - 排序和归并排序：O(n*log n)

        ![avatar](/img/dataStructureAndAlgorithm/MasterTheorem.jpg)

    - Array-内存中的连续存储空间

        ![avatar](/img/dataStructureAndAlgorithm/Array.jpg)

        ![avatar](/img/dataStructureAndAlgorithm/Array1.jpg)

        Array的查找的时间复杂度为o(1),插入和删除为o(n)复杂度，这也是数组作为存储在连续空间的数据的缺陷所在，为了改善插入和删除操作。因此后面产生了链表Linked List。

    - 链表
        - Single Linked List (单链表)

            ![avatar](/img/dataStructureAndAlgorithm/linkedList.jpg)

            - 单链表的变形形式（增加了头尾指针）

                ![avatar](/img/dataStructureAndAlgorithm/linkedList1.jpg)
            
            - 链表的插入和删除操作（时间复杂度为o(1)）

                ![avatar](/img/dataStructureAndAlgorithm/linkedList2.jpg)

                ![avatar](/img/dataStructureAndAlgorithm/linkedList3.jpg)
                
        - Doubly Linked List (双链表：既有前驱也有后继，查询更方便)

            ![avatar](/img/dataStructureAndAlgorithm/linkedList4.jpg)

            链表的时间复杂度总结：

            ![avatar](/img/dataStructureAndAlgorithm/linkedList5.jpg)

    - 堆栈和队列(Stack/Queue)

        1. Stack - First In Last Out (FILO)
            - Array or Linked List（实现）
                ![avatar](/img/dataStructureAndAlgorithm/stack.jpg)
        2. Queue - First In First Out (FIFO)
            - Array or Doubly Linked List（实现）
                ![avatar](/img/dataStructureAndAlgorithm/queue.jpg)

    - 各种数据结构的时间复杂度

        ![avatar](/img/dataStructureAndAlgorithm/BigONotation1.jpg)

        链接：http://www.bigocheatsheet.com/
    
- 优先队列(PriotityQueue)

    - 正常入，按照优先级出
    - 实现机制
        - Heap(堆)---Binary,Binomial,Fibonacca

            ![avatar](/img/dataStructureAndAlgorithm/miniHeap.jpg)
            ![avatar](/img/dataStructureAndAlgorithm/maxHeap.jpg)

            堆的介绍：https://en.wikipedia.org/wiki/Heap_(data_structure)

            ![avatar](/img/dataStructureAndAlgorithm/HeapBigONotation.jpg)

        - Binary S(earch Tree(二叉搜索树)
- 映射(Map) & 集合(Set)
    - HashTable(哈希表) & HashFunction(哈希函数) & Hash Collisions(哈希碰撞)
        ![avatar](/img/dataStructureAndAlgorithm/hashFunction.jpg)

        如何解决hash碰撞问题：建立链表放置重复元素

        ![avatar](/img/dataStructureAndAlgorithm/hashCollisions.jpg)
    - List vs Map vs Set

        > list就是一个链，所有元素再同一个表里面。map映射是key和value的关系。set可以理解为不重复的list(使用hash表或者二叉树实现)

        ![avatar](/img/dataStructureAndAlgorithm/listVSmapVSset.jpg)

    - HashMap,HashSet,TreeMap,TreeSet(hashtable vs binary-search-tree)
- 树 & 二叉树 & 二叉搜索树
    - tree & Binary Tree & Binary Search Tree
        ![avatar](/img/dataStructureAndAlgorithm/BinaryTree.jpg)

        - 二叉树就是每个树都有两个子节点，如上图所示，为特殊常用的树结构
        - 二叉搜索树(有序二叉树，排序二叉树)：是指一棵空树或者具有以下性质的二叉树(红黑树也是二叉搜索树)：
            - 左子树上所有的节点的值均小于它的根节点的值
            - 右子树上所有的节点的值均大于它的根节点的值
            - Recursively,左/右子树也分别为二叉查找树
             ![avatar](/img/dataStructureAndAlgorithm/BinarySearchTree.jpg)
        - 二叉树的遍历(pre-order/in-order/post-order: 前中后遍历)
            ![avatar](/img/dataStructureAndAlgorithm/sortedOrder.jpg)
            - 前序遍历(root-左-右)
                ![avatar](/img/dataStructureAndAlgorithm/preOrder.jpg)
            - 中序遍历(左-root-右)
                ![avatar](/img/dataStructureAndAlgorithm/inOrder.jpg)
            - 后序遍历(左-右-root)
                ![avatar](/img/dataStructureAndAlgorithm/postOrder.jpg)
            - 示例
                ![avatar](/img/dataStructureAndAlgorithm/sortedOrderExample.jpg)
    - Graph
        ![avatar](/img/dataStructureAndAlgorithm/Graph.jpg)

    > 可以简单这样理解：Linked List就是特殊化的tree(单个next指针), Tree就是特殊化的Graph
- 递归(Recursion)、分治(Divide & Conquer)
    - 递归：通过函数体来进行的循环
        ```py

        # n*(n-1)*(n-2)...*1
            def Factorial(n):
            if n <= 1:
                return 1
            return n * Factorial(n-1)
        ```

        ```py
            def recursion(level, param1, param2,...):
            # recursion terminal
            if level > MAX_LEVEL:
            print result
            return
            # process logic in recursion level
            process_data(level,data...)
            # drop down
            self.recursion(level+1, p1,...)
            # reverse the current level state if needed 
            reverse_state(level)
        ```

        ```py
        # Fibonacci array:1,1,2,3,5,8,13,21,34...
            def fib(n):
                if n == 0 or n == 1:
                    return n
                return fib(n-1)+fib(n-2)
        ```
    - 分治
        - 将大问题分成多个小问题解决，和递归不同的是没有中间问题，可以参照分布式的思想。
            ![avatar](/img/dataStructureAndAlgorithm/divideConquer.jpg)

            ```py
            # 分治递归方法
            def myPow(self,x,n):
                if not n:
                    return 1
                if n < 0:
                    return 1 / self.myPow(x,-n)
                if n % 2:
                    return x * self.myPow(x,n-1)
                return self.myPow(x*x,n/2   )
            ```
            ```py
            # 非递归方法
                def myPow(self, x, n):
                    if n < 0:
                        x = 1/x
                        n = -n
                    pow = 1
                    while n:
                        if n & 1:
                            pow *= x
                        x *= x
                        n >>= 1
                    return pow
            ```
- 贪心算法(Greedy)
    > 在对问题求解时，总是做出在当前看来最好的选择(部分情况下可以得到最优结果)

    ![avatar](/img/dataStructureAndAlgorithm/greedy.jpg)
    ![avatar](/img/dataStructureAndAlgorithm/greedy1.jpg)

- 广度优先搜索(Breadth-First-Fearch)---非递归方法

    ![avatar](/img/dataStructureAndAlgorithm/Search.jpg)
    ![avatar](/img/dataStructureAndAlgorithm/bfs.jpg)
    ![avatar](/img/dataStructureAndAlgorithm/bfs1.jpg)

- 深度优先搜索(Depth-First-Fearch)---推荐用递归方法

    ![avatar](/img/dataStructureAndAlgorithm/dfs.jpg)

    - 对比DFS和BFS

    ![avatar](/img/dataStructureAndAlgorithm/bfsANDdfs.jpg)
    ![avatar](/img/dataStructureAndAlgorithm/bfsANDdfs1.jpg)

    - 示例

    ![avatar](/img/dataStructureAndAlgorithm/dfsExample.jpg)
    ![avatar](/img/dataStructureAndAlgorithm/dfsExample1.jpg)
- 剪枝
- 二分查找
- 字典树
- 位运算
- 动态规划
- LRU Cache
- 布隆过滤器


> 本文首次发布于 [SkioFox Blog](http://blog.skiofox.top), 作者 [SkioFox](https://github.com/LoverFancy/) ,转载请保留原文链接.