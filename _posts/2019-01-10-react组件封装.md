---
layout:     post
title:      react组件封装
subtitle:   react组件封装
date:       2019-01-10
author:     SkioFox
header-img: img/post-bg-keybord.jpg
catalog: true
tags:
- react
- 组件
- 模块化
- 权限

---

## 基于antd的form的封装
> 通过props传递数据和方法，将数据在父子之间传递，子组件中通过对数据的获取和类型判断动态生成formItem项，实现form的封装
```js
  import React from 'react'
  import { Input, Select, Form, Button, Checkbox, Radio, DatePicker} from 'antd'
  import Utils from '../../utils/utils';
  const FormItem = Form.Item;
  const Option = Select.Option;

  class FilterForm extends React.Component{

      handleFilterSubmit = ()=>{
          // 获取表单的值
          let fieldsValue = this.props.form.getFieldsValue();
          // 将值传递回父级
          this.props.filterSubmit(fieldsValue);
      }
      // 重置
      reset = ()=>{
          this.props.form.resetFields();
      }

      initFormList = ()=>{
          // 获取antD的表单方法
          const { getFieldDecorator } = this.props.form;
          // 获取传递进来的formList
          const formList = this.props.formList;
          const formItemList = [];
          if (formList && formList.length>0){
              // 遍历表单数据
              formList.forEach((item,i)=>{
                  let label = item.label;
                  let field = item.field;
                  let initialValue = item.initialValue || '';
                  let placeholder = item.placeholder;
                  let width = item.width;
                  // 依据type类型获取formItem组件项
                  if (item.type == '时间查询'){
                      const begin_time = <FormItem label="订单时间" key={field}>
                          {
                              getFieldDecorator('begin_time')(
                                  <DatePicker showTime={true} placeholder={placeholder} format="YYYY-MM-DD HH:mm:ss"/>
                              )
                          }
                      </FormItem>;
                      formItemList.push(begin_time)
                      const end_time = <FormItem label="~" colon={false} key={field}>
                          {
                              getFieldDecorator('end_time')(
                                  <DatePicker showTime={true} placeholder={placeholder} format="YYYY-MM-DD HH:mm:ss" />
                              )
                          }
                      </FormItem>;
                      formItemList.push(end_time)
                  }else if(item.type == 'INPUT'){
                      const INPUT = <FormItem label={label} key={field}>
                          {
                              getFieldDecorator([field],{
                                  initialValue: initialValue
                              })(
                                  <Input type="text" placeholder={placeholder} />
                              )
                          }
                      </FormItem>;
                      formItemList.push(INPUT)
                  } else if (item.type == 'SELECT') {
                      const SELECT = <FormItem label={label} key={field}>
                          {
                              getFieldDecorator([field], {
                                  initialValue: initialValue
                              })(
                                  <Select
                                      style={{ width: width }}
                                      placeholder={placeholder}
                                  >
                                      {/* getOptionList()依据data动态获取option */}
                                      {Utils.getOptionList(item.list)}
                                  </Select>
                              )
                          }
                      </FormItem>;
                      formItemList.push(SELECT)
                  } else if (item.type == 'CHECKBOX') {
                      const CHECKBOX = <FormItem label={label} key={field}>
                          {
                              getFieldDecorator([field], {
                                  valuePropName: 'checked',
                                  initialValue: initialValue //true | false
                              })(
                                  <Checkbox>
                                      {label}
                                  </Checkbox>
                              )
                          }
                      </FormItem>;
                      formItemList.push(CHECKBOX)
                  }
              })
          }
          return formItemList;
      }
      render(){
          return (
              <Form layout="inline">
                  { this.initFormList() }
                  <FormItem>
                      <Button type="primary" style={{ margin: '0 20px' }} onClick={this.handleFilterSubmit}>查询</Button>
                      <Button onClick={this.reset}>重置</Button>
                  </FormItem>
              </Form>
          );
      }
  }
  // getFieldDecorator()内部实现了表单数据的双向绑定
  export default Form.create({})(FilterForm);
```
## 请求与全局状态以及拦截器的封装
> 通过对请求的二次封装，返回promise对象进行异步处理，从而实现统一的请求和错误提示。通过请求状态控制全局loading的显示。这里仅对jsonp和get请求举例
```js
  import JsonP from 'jsonp'
  import axios from 'axios'
  import { Modal } from 'antd'
  export default class Axios {
      // 跨域请求
      static jsonp(options) {
          return new Promise((resolve, reject) => {
              JsonP(options.url, {
                  param: 'callback'
              }, function (err, response) {
                  // console.log(response)
                  if (response.status == 'success') {
                      resolve(response);
                  } else {
                      reject(response.messsage);
                  }
              })
          })
      }

      static ajax(options){   
          let loading;
          // 全局的loading状态，在请求未成功时会触发
          if (options.data && options.data.isShowLoading !== false){
              loading = document.getElementById('ajaxLoading');
              loading.style.display = 'block';
          }
          let baseApi = 'https://www.easy-mock.com/mock/5a7278e28d0c633b9c4adbd7/api';
          return new Promise((resolve,reject)=>{
              axios({
                  url:options.url,
                  method:'get',
                  baseURL:baseApi,
                  timeout:5000,
                  params: (options.data && options.data.params) || ''
              }).then((response)=>{
                  if (options.data && options.data.isShowLoading !== false) {
                      loading = document.getElementById('ajaxLoading');
                      loading.style.display = 'none';
                  }
                  if (response.status == '200'){
                      let res = response.data;
                      if (res.code == '0'){
                          resolve(res);
                      }else{
                          // 错误提示
                          Modal.info({
                              title:"提示",
                              content:res.msg
                          })
                      }
                  }else{
                      reject(response.data);
                  }
              })
          })  
      }
  }     

```
## 基于react的权限控制
> 通过RBAC角色权限模型进行权限设计

> 本文首次发布于 [SkioFox Blog](http://blog.skiofox.top), 作者 [SkioFox](https://github.com/LoverFancy/) ,转载请保留原文链接.