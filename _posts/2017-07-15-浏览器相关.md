---
layout:     post
title:      浏览器相关
subtitle:   浏览器相关
date:       2017-07-15
author:     SkioFox
header-img: img/post-bg-YesOrNo.jpg
catalog: true
tags:
- 重绘
- 回流
- 渲染
- http

---

> 在解释回流和重绘之前我们先来了解下浏览器的整个渲染过程，如下几个图所示，这里不过多展开：

## 浏览器渲染原理
![avatar](/img/brower-render/brower-render-analysis.png)

## 浏览器工作流程
![avatar](/img/brower-render/brower-render-process.png)

## 渲染树
![avatar](/img/brower-render/render-tree.png)

## DOM树
![avatar](/img/brower-render/render-tree-1.png)

## 重绘

> 待补充

## 回流(重排)

> 待补充

## http 相关知识
### HTTP/TCP/Socket的区别与联系
1. TCP连接

    手机能够使用联网功能是因为手机底层实现了TCP/IP协议，可以使手机终端通过无线网络建立TCP连接。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。

    建立起一个TCP连接需要经过“三次握手”：

    ![avatar](/img/brower-render/connect.png)

    第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

    第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

    第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

    握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次挥手”（过程就不细写了，就是服务器和客户端交互，最终确定断开）

    ![avatar](/img/brower-render/notconnect.png)

    （1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

    （2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

    （3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
    
    （4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

2. HTTP连接

    HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。

    HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。

    1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。

    2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。

    由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客 户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。


3. SOCKET原理

    3.1 套接字（socket）概念

        套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。

        应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。

    3.2 建立socket连接

        建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。

        套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。

        服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。

        客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。

        连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户 端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。

4. SOCKET连接与TCP连接

    创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。


5. Socket连接与HTTP连接

    由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致Socket连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。

    而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。

    很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给 客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以 保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。
### 相互关系

    之前我一直以为Http和Tcp是两种不同的，但是地位对等的协议，虽然知道TCP是传输层，而http是应用层今天学习了下，知道了http是要基于TCP连接基础上的，简单的说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。

    第一：从传输层，先说下TCP连接，我们要和服务端连接TCP连接，需要通过三次连接，包括：请求，确认，建立连接。即传说中的“三次握手协议”。

        第一次：C发送一个请求连接的位码SYN和一个随机产生的序列号给S，然后S收到了这些数据。

        第二次:S收到了这个请求连接的位码，啊呀，有人向我发出请求了么，那我要不要接受他的请求，得实现确认一下，于是，发送了一个确认码 ACN（seq+1），和SYN，S给C，然后C收到了，这个是第二次连接。

        第三次：C收到了确认的码和之前发送的SYN一比较，偶哟，对上了么，于是他又发送了一个ACN（SEQ+1）给S，S收到以后就确定建立连接，至此，TCP连接建立完成。

    简单就是：请求，确认，连接。

    第二：从实际上的数据应用来说HTTP

    在前面客户端和应用服务器建立TCP连接之后，就需要用http协议来传送数据了，HTTP协议简单来说，还是请求，确认，连接。

    总体就是C发送一个HTTP请求给S，S收到了这个http请求，然后返回给C http响应，然后C的中间件或者说浏览器把这些数据渲染成为了网页，展示在用户面前。

    第一：发送一个http请求给S，这个请求包括请求头和请求内容：

    request header：

        包括了，1.请求的方法是POST/GET,请求的URL，http协议版本2.请求的数据，和编码方式3是否有cookie和cooies，是否缓存等。

        post和get请求方式的区别是，get把请求内容放在URL后面，但是URL长度有限制。而post是以表单的形势，适合要输入密码之类的，因为不在URL中显示，所以比较安全。

    request body：

    即请求的内容.

        第二：S收到了http请求，然后根据请求头，返回http响应。

    response header：包括了1.cookies或者sessions2.状态吗3.内容大小等

    response body：

        即响应的内容，包括，JS什么的。

        第三，C收到了以后，就由浏览器完成一系列的渲染，包括执行JS脚本等。

        这就是我所理解的webTCP,HTTP基础知识，待续。。。。。

    TCP是底层通讯协议，定义的是数据传输和连接方式的规范
    HTTP是应用层协议，定义的是传输数据的内容的规范
    HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP      

    HTTP支持的是www服务 
    而TCP/IP是协议 
    它是Internet国际互联网络的基础。TCP/IP是网络中使用的基本的通信协议。 
    TCP/IP实际上是一组协议，它包括上百个各种功能的协议，如：远程登录、文件传输和电子邮件等，而TCP协议和IP协议是保证数据完整传输的两个基本的重要协议。通常说TCP/IP是Internet协议族，而不单单是TCP和IP。
### http和https

    https的SSL加密是在传输层实现的。

    (1)http和https的基本概念

    http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

    https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

    https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。

    (2)http和https的区别？

    http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。
    主要的区别如下：

    Https协议需要ca证书，费用较高。

    http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

    使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443

    http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

    (3)https协议的工作原理

    客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

    客户使用https url访问服务器，则要求web 服务器建立ssl链接。

    web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。

    客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。

    客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。

    web服务器通过自己的私钥解密出会话密钥。

    web服务器通过会话密钥加密与客户端之间的通信。

    (4)https协议的优点

    使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

    HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

    HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

    谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。

    (5)https协议的缺点

    https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。

    https缓存不如http高效，会增加数据开销。

    SSL证书也需要钱，功能越强大的证书费用越高。

    SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。
### TCP和UDP的区别

（1）TCP是面向连接的，udp是无连接的即发送数据前不需要先建立链接。

（2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。

（3）TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。

（4）TCP只能是1对1的，UDP支持1对1,1对多。

（5）TCP的首部较大为20字节，而UDP只有8字节。

（6）TCP是面向连接的可靠性传输，而UDP是不可靠的。
### WebSocket的实现和应用

    (1)什么是WebSocket?

    WebSocket是HTML5中的协议，支持持久连续，http协议不支持持久性连接。Http1.0和HTTP1.1都不支持持久性的链接，HTTP1.1中的keep-alive，将多个http请求合并为1个

    (2)WebSocket是什么样的协议，具体有什么优点？

    HTTP的生命周期通过Request来界定，也就是Request一个Response，那么在Http1.0协议中，这次Http请求就结束了。在Http1.1中进行了改进，是的有一个connection：Keep-alive，也就是说，在一个Http连接中，可以发送多个Request，接收多个Response。但是必须记住，在Http中一个Request只能对应有一个Response，而且这个Response是被动的，不能主动发起。

    WebSocket是基于Http协议的，或者说借用了Http协议来完成一部分握手，在握手阶段与Http是相同的。我们来看一个websocket握手协议的实现，基本是2个属性，upgrade，connection。

    基本请求如下：
```
    GET /chat HTTP/1.1
    Host: server.example.com
    Upgrade: websocket
    Connection: Upgrade
    Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
    Sec-WebSocket-Protocol: chat, superchat
    Sec-WebSocket-Version: 13
    Origin: http://example.com

    多了下面2个属性：
    1 Upgrade:webSocket
    2 Connection:Upgrade


    告诉服务器发送的是websocket

    1 Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
    2 Sec-WebSocket-Protocol: chat, superchat
    3 Sec-WebSocket-Version: 13

```
### HTTP请求的方式，HEAD方式

head：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头

options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等。
###  一个图片url访问后直接下载怎样实现？

请求的返回头里面，用于浏览器解析的重要参数就是OSS的API文档里面的返回http头，决定用户下载行为的参数。

下载的情况下：

1. x-oss-object-type:

Normal

2. x-oss-request-id:

598D5ED34F29D01FE2925F41

3. x-oss-storage-class:

Standard
### web Quality（无障碍）

    能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。

    残障人士指的是那些带有残疾或者身体不健康的用户。
    使用alt属性：
    ```
    <img src="person.jpg"  alt="this is a person"/>
    ```
    有时候浏览器会无法显示图像。具体的原因有：

    用户关闭了图像显示

    浏览器是不支持图形显示的迷你浏览器

    浏览器是语音浏览器（供盲人和弱视人群使用）

    如果您使用了alt 属性，那么浏览器至少可以显示或读出有关图像的描述
### http2.0

    http2.0是基于1999年发布的http1.0之后的首次更新。

    提升访问速度（请求资源所需时间更少，访问速度更快，相比http1.0）

    允许多路复用：多路复用允许同时通过单一的HTTP2连接发送多重请求-响应信息。在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。

    二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码

    首部压缩

    服务器端推送
### 请求状态码
    (1)400状态码：请求无效

    产生原因：

    前端提交数据的字段名称和字段类型与后台的实体没有保持一致

    前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。

    解决方法：

    对照字段的名称，保持一致性

    将obj对象通过JSON.stringify实现序列化

    (2)401状态码：当前请求需要用户验证

    (3)403状态码：服务器已经得到请求，但是拒绝执行

    (4) 汇总

        100	Continue	继续。客户端应继续其请求

        101	Switching Protocols	切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议

        200	OK	请求成功。一般用于GET与POST请求

        201	Created	已创建。成功请求并创建了新的资源

        202	Accepted	已接受。已经接受请求，但未处理完成

        203	Non-Authoritative Information	非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本

        204	No Content	无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档

        205	Reset Content	重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域

        206	Partial Content	部分内容。服务器成功处理了部分GET请求

        300	Multiple Choices	多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择

        301	Moved Permanently	永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替

        302	Found	临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI

        303	See Other	查看其它地址。与301类似。使用GET和POST请求查看

        304	Not Modified	未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源

        305	Use Proxy	使用代理。所请求的资源必须通过代理访问

        306	Unused	已经被废弃的HTTP状态码

        307	Temporary Redirect	临时重定向。与302类似。使用GET请求重定向

        400	Bad Request	客户端请求的语法错误，服务器无法理解

        401	Unauthorized	请求要求用户的身份认证

        402	Payment Required	保留，将来使用

        403	Forbidden	服务器理解请求客户端的请求，但是拒绝执行此请求

        404	Not Found	服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面

        405	Method Not Allowed	客户端请求中的方法被禁止

        406	Not Acceptable	服务器无法根据客户端请求的内容特性完成请求

        407	Proxy Authentication Required	请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权
        408	Request Time-out	服务器等待客户端发送的请求时间过长，超时

        409	Conflict	服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突

        410	Gone	客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置

        411	Length Required	服务器无法处理客户端发送的不带Content-Length的请求信息

        412	Precondition Failed	客户端请求信息的先决条件错误

        413	Request Entity Too Large	由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息

        414	Request-URI Too Large	请求的URI过长（URI通常为网址），服务器无法处理

        415	Unsupported Media Type	服务器无法处理请求附带的媒体格式

        416	Requested range not satisfiable	客户端请求的范围无效

        417	Expectation Failed	服务器无法满足Expect的请求头信息

        500	Internal Server Error	服务器内部错误，无法完成请求

        501	Not Implemented	服务器不支持请求的功能，无法完成请求

        502	Bad Gateway	作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应

        503	Service Unavailable	由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中

        504	Gateway Time-out	充当网关或代理的服务器，未及时从远端服务器获取请求

        505	HTTP Version not supported	服务器不支持请求的HTTP协议的版本，无法完成处理
### ajax/axios/fetch 请求

> Fetch被称为下一代Ajax技术,采用Promise方式来处理数据。是一种简洁明了的API，比XMLHttpRequest更加简单易用。

对比下ajax和axios和fetch请求

- jquery的 ajax请求

```js
    $.ajax({
        type: 'POST',
        url: url,
        data: data,
        dataType: dataType,
        success: function () {},
        error: function () {}
    });
```

传统 Ajax 指的是 XMLHttpRequest（XHR）， 最早出现的发送后端请求技术，隶属于原始js中，核心使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现回调地狱。

JQuery ajax 是对原生XHR的封装，除此以外还增添了对JSONP的支持。经过多年的更新维护，真的已经是非常的方便了，优点无需多言；如果是硬要举出几个缺点，那可能只有：

    1.本身是针对MVC的编程,不符合现在前端MVVM的浪潮
    2.基于原生的XHR开发，XHR本身的架构不清晰。
    3.JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务）
    4.不符合关注分离（Separation of Concerns）的原则
    5.配置和调用方式非常混乱，而且基于事件的异步模型不友好。
- axios请求

axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征：

    1.从浏览器中创建 XMLHttpRequest
    2.支持 Promise API
    3.客户端支持防止CSRF
    4.提供了一些并发请求的接口（重要，方便了很多的操作）
    5.从 node.js 创建 http 请求
    6.拦截请求和响应
    7.转换请求和响应数据
    8.取消请求
    9.自动转换JSON数据

    ```js
    axios({
        method: 'post',
        url: '/user/12345',
        data: {
            firstName: 'Fred',
            lastName: 'Flintstone'
        }
    })
    .then(function (response) {
        console.log(response);
    })
    .catch(function (error) {
        console.log(error);
    });
    ```

PS:防止CSRF:就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。

- fetch请求

    get请求

    ```js
        fetch('https://api.myjson.com/bins/of6pw')
            .then(function(response) {
                return response.json();
        })
            .then(function(myJson) {
                console.log(myJson);
        });
    ```

    post请求

    ```JS
        fetch('https://jsonplaceholder.typicode.com/posts', {
            method: 'POST',
            body: JSON.stringify({
                name: "ceido",
                age: 100
        }),
        headers: {
            "Content-type": "application/json; charset=UTF-8"
            }
        })
        .then(response => response.json())
        .then(json => console.log(json))
    ```
fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。

fetch的优点：

    1. 语法简洁，更加语义化
    2. 基于标准 Promise 实现，支持 async/await
    3. 同构方便，使用 [isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch)
    4. 更加底层，提供的API丰富（request, response）
    5. 脱离了XHR，是ES规范里新的实现方式


缺点：fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。

    1. fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回400，500错误码时并不会reject，只有网络错误这些导致请求不能完成时，fetch才会被reject。
    2. fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})
    3. fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
    4. fetch没有办法原生监测请求的进度，而XHR可以。

fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？

原因很简单，因为你用fetch的post请求的时候，导致fetch第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。

总结：axios既提供了并发的封装，也没有fetch的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。
### Cookie、sessionStorage、localStorage的区别

    共同点：都是保存在浏览器端，并且是同源的.

    Cookie：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约4K左右）

    sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）

    localStorage：localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）

    补充说明一下cookie的作用：

    保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。

    跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。
### Cookie和session的区别：
    
    HTTP是一个无状态协议，因此Cookie的最大的作用就是存储sessionId用来唯一标识用户

    cookie数据存放在客户的浏览器上，session数据放在服务器上。

    cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。

    session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。

    单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。    
### web worker

    在HTML页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后，页面才变成可相应。web worker是运行在后台的js，独立于其他脚本，不会影响页面你的性能。并且通过postMessage将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。
### iframe是什么？有什么缺点？

    定义：iframe元素会创建包含另一个文档的内联框架

    提示：可以将提示文字放在<iframe></iframe>之间，来提示某些不支持iframe的浏览器

    缺点：

    会阻塞主页面的onload事件

    搜索引擎无法解读这种页面，不利于SEO

    iframe和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。

     iframe通信，同源和不同源两种情况,多少种方法？
     
     同源:可以直接互相调用方法和属性。

        ```js
        // 子调用父元素

            window.parent.document.getElementById ("元素id");
            $("#id", parent.document);


        // 子调用父变量/方法

            window.parent.func();//调用方法
            window.parent.value;//调用变量


        // 父调用子元素

            window.frames[iframe序号].document.getElementById("元素id");
            $("#iframeID").contents().find("#元素id");


        // 父调用子变量/方法

            window.frames[iframe序号].func();//调用方法
            window.frames[iframe序号].value;//调用变量
        ```
        
     不同源：使用postMessage(data,origin)

        data: 要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，考虑到兼容性需要使用JSON.stringify()方法对对象参数序列化。

        origin: 字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为"*"，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

        ```js
            // 子向父通信,源可以为*
            window.parent.postMessage(input, "*");
            // 父向子通信,源必须为子的源
            var child = $('#childIframe');
            child.contentWindow.postMessage(input, 'http://localhost:8081');
            // 接收信息
            window.addEventListener('message', function(e){...});
        ```

        最近公司项目内通过iframe引入了另一个项目的内容，子域和父域不属于同域，但需要将父域token传入子域供子域的http请求使用，若子域内的请求判断该token已过期，需要子域调起父域退出登录。问题就卡在跨域通信这个关键点上

        postMessage方法发送数据，监听message事件获取数据

        ```jsx
            // 父域部分
            export default class ParentComponent extends React.Component {
                componentDidMount() {
                    window.onmessage = e => {
            //监听message事件
                        if (e.data === 'login') {
                            //根据子域传送来的数据执行指定操作，传送来的数据在data中
                        }
                    };
                }
                sendToken = () => {
            //必须是iframe加载完成后才可以向子域发送数据
                    const childFrameObj = document.getElementById('calculation');
                    childFrameObj.contentWindow.postMessage('要发送的数据，必须是字符串', '*');
                };
                render() {
                    return (
                        <div >
                            <iframe
                                id="calculation"
                                src=""
                                onLoad={this.sendToken}
                            />
                        </div>
                    );
                }
            }
        ```

        ```jsx
            // 子域部分
            window.parent.postMessage('需要传送的数据，必须是字符串', '*'); //向父域传送数据

            export default class ChildComponent extends React.Component {
                componentDidMount() {
                // 首次打开时需要监听message事件，接收父域传送来的数据
                //以我的项目里接收token举例
                    if (sessionStorage.token) {
                        //若子域内已存在token则不再需要监听message事件
                    //do something
                        window.onmessage = null;
                        return;
                    }
                //若token不存在
                    window.onmessage = e => {
                        if (e.data) {
                            sessionStorage.token = e.data;
                            //do something
                        }
                    };
                render() {
                    return (
                        <div >
                            xxxxxx
                        </div>
                    );
                }
            }

        ```

### Doctype作用?严格模式与混杂模式如何区分？它们有何意义?

    Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。

    严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行。

    混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。  
### Cookie如何防范XSS攻击

    XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie：

    httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。

    secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。

    结果应该是这样的：Set-Cookie=<cookie-value>.....
### 一句话概括RESTFUL
    就是用URL定位资源，用HTTP描述操作
### 强，协商缓存

缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。

![avatar](/img/brower-render/cache.jpg)

强缓存相关字段有expires，cache-control。如果cache-control与expires同时存在的话，cache-control的优先级高于expires。

协商缓存相关字段有Last-Modified/If-Modified-Since，Etag/If-None-Match
### 待续
> 本文首次发布于 [SkioFox Blog](http://blog.skiofox.top), 作者 [SkioFox](https://github.com/LoverFancy/) ,转载请保留原文链接.