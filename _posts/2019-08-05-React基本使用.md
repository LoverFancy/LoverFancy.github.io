---
layout:     post
title:      react 基础
subtitle:   react 基本使用和API
date:       2018-08-05
author:     SkioFox
header-img: img/post-bg-js-version.jpg
catalog: true
tags:
- react
---

## react 组件

> React 的世界里一切皆是组件，我们使用class语法构建一个最基本的组件，组件的使用方式和HTML相同，组件的render函数返回页面渲染的一个JSX，然后使用ReactDom渲染到页面里

```js
class App extends React.Component {
  render() {
    return <div> Hello React </div>
  }
}

ReactDOM.render(
  <App />,
  mountNode
)
```
## 属性传递
>React组件使用和html类似的方式传递参数，在组件内部，使用this.props获取所有的传递的参数，在JSX里使用变量，使用{}包裹

```js
class App extends React.Component {
  render() {
    return <div> Hello {this.props.name} </div>
  }
}

ReactDOM.render(
  <App name="React" />,
  mountNode
)
```
## JSX
>JSX是一种js的语法扩展，表面上像HTML，本质上还是通过babel转换为js执行，所以在JSX里我们是可以在{}中使用js的语法

>JSX本质上就是转换为React.createElement在React内部构建虚拟Dom，最终渲染出页面

```js
class App extends React.Component {
  render() {
    return (
      <div>
        Hello {this.props.name}, I am {2 + 2} years old
      </div>
    )
  }
}

ReactDOM.render(
  <App name="React" />, 
  mountNode
)
```
## State和事件绑定

> React内部通过this.state变量来维护内部的状态，并且通过this.setState来修改状态，render里用到的state变量，也会自动渲染到UI

>我们现在constructor来初始化state,在JSX里使用this.state.num获取，然后jsx里使用onClick绑定点击事件，注意这里constructor里使用bind方法绑定this指向，然后内部调用this.setState修改值，注意这里不能写成this.state.num+1,而是要调用this.setState，返回一个全新的num值
```js
class Counter extends React.Component {
  constructor(props){
    super(props)
    // state必须写在constructor内,constructor才能初始化state
    this.state = {
      num:1
    }
    // 绑定this为当前调用的对象=>这里指代button
    this.handleClick = this.handleClick.bind(this)
  }
  handleClick(){
    this.setState({
      num:this.state.num+1
    })
  }
  render() {
    return (
      <div>
        <p>{this.state.num}</p>
        <button onClick={this.handleClick}>click</button>
      </div>
    )
  }
}

ReactDOM.render(
  <Counter />,
  mountNode
)
```
## 生命周期
> 在组件内部可以声明一些特殊的方法，会在组件的不同阶段执行，比如组件加载完毕后会执行componentDidMount函数,组件更新的时候，会执行shouldComponentUpdate函数。
> 如下示例中如果shouldComponentUpdate返回true的话，就会一次执行componentWillMount、render，componentDidMount，如果返回false的话，就不会执行,代表组件的更新
```js
class Counter extends React.Component {
  constructor(props){
    super(props)
    this.state = {
      num:1
    }
    this.handleClick = this.handleClick.bind(this)
  }
  componentDidMount(){
    console.log('componentDidMount 函数触发')
  }
  shouldComponentUpdate(nextProps,nextState){
    if (nextState.num%2) {
      return true
    }
    return false
  }
  // componentWillMount() {
  //   // 此时可以访问属性和状态了，可以进行api调用，但没办法做dom相关操作
  //   console.log("2.组件将要挂载");
  // }

  // componentDidMount() {
  //   // 组件已挂载，可进行状态更新操作
  //   console.log("3.组件已经挂载");
  // }

  // componentWillReceiveProps() {
  //   // 父组件传递的属性有变化，做相应响应
  //   console.log("4.组件属性更新了");
  // }

  // shouldComponentUpdate() {
  //   // 组件是否需要更新，返回布尔值，优化点
  //   console.log("5.组件是否应该更新？");
  //   return true;
  // }

  // componentWillUpdate() {
  //   console.log("6.组件将要更新");
  // }
  // componentDidUpdate() {
  //   console.log("7.组件已经更新");
  // }
  handleClick(){
    this.setState({
      num:this.state.num+1
    })
  }
  render() {
    return (
      <div>
        <p>{this.state.num}</p>
        <button onClick={this.handleClick}>click</button>
      </div>
    )
  }
}
ReactDOM.render(
  <Counter />,
  mountNode
)
```
## 表单

> 一个常见的表单由form input label等标签构成，我们通过onChange和控制value的值，最终通过state，让原生的html输入内容和React链接起来
```js
class TodoList extends React.Component {
  constructor(props){
    super(props)
    this.state = {
      text:''
    }
    this.handleClick = this.handleClick.bind(this)
    this.handleChange = this.handleChange.bind(this)
  }
  handleClick(){
    if (this.state.text) {
      this.setState({
        text:''
      })
    }
  }
  handleChange(e){
    this.setState({
      text:e.target.value
    })
  }
  render() {
    return (
      <div>
        {this.state.text}
        <input type="text" value={this.state.text} onChange={this.handleChange}/>
        <button onClick={this.handleClick}>clear</button>      
      </div>
    )
  }
}


ReactDOM.render(
  <TodoList />,
  mountNode
)
```
## 渲染列表
>页面里序列化的数据，比如用户列表，都是一个数组，我们通过map函数把数字直接映射为JSX,但是我们直接渲染列表，打开console的时候会看到Each child in an array or iterator should have a unique "key" prop.报错。
>渲染列表的时候，我们需要每个元素都有一个唯一的key属性，这样React在数据变化的时候，知道哪些dom应该发生变化 尤其注意key要唯一，使用每个字段唯一id，或者使用索引
```JS
class TodoList extends React.Component {
  constructor(props){
    super(props)
    this.state = {
      todos:['Learn React','Learn Ant-design','Learn Koa'],
      text:''
    }
    this.handleClick = this.handleClick.bind(this)
    this.handleChange = this.handleChange.bind(this)
  }
  handleClick(){
    if (this.state.text) {
      this.setState(state=>({
        todos:[...state.todos,state.text],
        text:''
      }))
    }

  }
  handleChange(e){
    this.setState({
      text:e.target.value
    })
  }
  render() {
    return (
      <div>
        <input type="text" value={this.state.text} onChange={this.handleChange}/>
        <button onClick={this.handleClick}>add</button>
        <ul>
          {this.state.todos.map(v=>{
            return <li key={v}>{v}</li>
          })}
        </ul>
      </div>
    )
  }
}


ReactDOM.render(
  <TodoList />,
  mountNode
)
```
## React16新增了什么
>Facebook 官方发布了 React 16.0。相较于之前的 15.x 版本，v16是第一个核心模块重写的版本，并且在异常处理，核心架构和服务端渲染方面都有更新。
  - render 函数支持返回数组和字符串
  - 异常处理，添加componentDidCatch钩子获取组件错误
  - 新的组件类型 portals 可以渲染当前容器dom之外的节点
  - 打包的文件体积减少 30%
  - 更换开源协议为MIT许可
  - Fiber架构，支持异步渲染
  - 更好的服务端渲染，支持字节流渲染
```js

class React16 extends React.Component {
  constructor(props){
    super(props)
    this.state={hasError:false}
  }
  componentDidCatch(error, info) {
    this.setState({ hasError: true })
  }

  render() {
    return (
      <div>
        {this.state.hasError ? <div>出错了</div>:null}
        <ClickWithError />
        <FeatureReturnFragments />
      </div>
    )
  }
}

class ClickWithError extends React.Component{
   constructor(props){
    super(props)
    this.state = {error:false}
    this.handleClick = this.handleClick.bind(this)
  }
  handleClick(){
    this.setState({
      error:true
    })
  }
  render() {
    if (this.state.error) {
      throw new Error('出错了！')
    }
    return <button onClick={this.handleClick}>抛出错误</button>
  }
}
class FeatureReturnFragments extends React.Component{
  render(){
    return [
      <p key="key1">React很不错</p>,
      "文本1",
      <p key="key2">Antd-desing也很赞</p>,
      "文本2"
   ]
  }
}

ReactDOM.render(
  <React16 />,
  mountNode
)
```
## 官方脚手架

```js
    npm install -g create-react-app
    create-react-app projectName
```
> 本文首次发布于 [SkioFox Blog](http://skiofox.top), 作者 [SkioFox](https://github.com/LoverFancy/) ,转载请保留原文链接.